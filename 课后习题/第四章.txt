4.1
一、判断题 
1. 有向图中，如果从顶点 u 到顶点 v 有路径，那么从顶点 v 到顶点 u 一定有路径。（  ）  
2. 无向图中，如果两个顶点之间有边，那么这两个顶点一定连通。（  ）  
3. 欧拉路径是指在图中遍历每条边恰好一次的路径。（  ）  
4. 哈密顿路径是指在图中遍历每条边恰好一次的路径。（  ）  
二、选择题 
1. 下列关于图的说法中，正确的是（ ）。
A. 有向图中，如果从顶点 u 到顶点 v 有路径，那么从顶点 v 到顶点 u 一定有路径。
B. 无向图中，如果两个顶点之间有边，那么这两个顶点一定连通。
C. 有向图中，如果从顶点 u 到顶点 v 有路径，那么从顶点 v 到顶点 u 一定没有路径。
D. 无向图中，如果两个顶点之间没有边，那么这两个顶点一定不连通。
2. 下列关于图的路径的说法中，错误的是（ ）。
A. 简单路径是指路径中顶点重复的路径。
B. 回路是指起终点相同的路径。
C. 欧拉路径是指在图中遍历每条边恰好一次的路径。
D. 哈密顿路径是指在图中遍历每个顶点恰好一次的路径。
三、计算题
1. 给定一个无向图，顶点集合为 V={A,B,C,D,E}，边集合为 E={(A,B),(A,C),(B,C),(B,D),(C,D),(D,E)}。判断该图是否为连通图。
2. 给定一个有向图，顶点集合为 V={A,B,C,D}，边集合为 E={(A,B),(B,C),(C,D),(D,A),(A,C)}。判断该图是否为强连通图。
四、应用题
1. 在一个交通网络中，有5个城市，分别用顶点 A,B,C,D,E 表示。城市之间的道路用边表示，道路的长度用边的权重表示。给定边集合和权重如下：
E={(A,B,10),(A,C,15),(B,C,20),(B,D,25),(C,D,30),(D,E,35)}。
问题：从城市 A 到城市 E 的最短路径是什么？
2. 在一个社交网络中，有4个用户，分别用顶点 A,B,C,D 表示。用户之间的关系用边表示，给定边集合如下：
E={(A,B),(A,C),(B,C),(B,D),(C,D)}。
问题：该社交网络是否为连通图？为什么？
参考答案与解析：
第一节：
# 一、判断题 
1. **答案**：错 
- **解析**：在有向图中，边具有方向性。从顶点\(u\)到顶点\(v\)有路径，由于边的方向限制，从顶点\(v\)到顶点\(u\)不一定存在路径。例如存在有向边\((u, v)\)，但不存在\((v, u)\)时，就满足从\(u\)到\(v\)有路径，而从\(v\)到\(u\)无路径的情况。 
- **核心知识点**：有向图中路径的方向性，有向图中边的方向决定了路径的走向，与无向图中路径的无向性形成对比。 
2. **答案**：对 
- **解析**：在无向图中，根据连通的定义，若两个顶点之间存在边相连，那么这两个顶点必然是连通的，因为边的无向性使得两个顶点可以相互到达。
 - **核心知识点**：无向图中连通的概念，无向图中边的无向性使得顶点之间的连通关系相对直接，只要有边相连就满足连通条件。 
3. **答案**：对 
- **解析**：欧拉路径的定义明确指出，在图中遍历每条边恰好一次的路径即为欧拉路径，这是欧拉路径的基本特征。 
- **核心知识点**：欧拉路径的定义，理解欧拉路径强调的是对图中所有边的遍历且每条边仅遍历一次。 
4. **答案**：错 
- **解析**：哈密顿路径是指在图中遍历每个顶点恰好一次的路径，而不是遍历每条边恰好一次。遍历边恰好一次是欧拉路径的定义，要注意区分两者。 
- **核心知识点**：哈密顿路径与欧拉路径定义的区别，哈密顿路径关注的是顶点的遍历，每个顶点仅经过一次；欧拉路径关注的是边的遍历，每条边仅经过一次。 
# 二、选择题 
1. **答案**：B 
- **解析**： - A选项：有向图中，从顶点\(u\)到顶点\(v\)有路径，由于边的方向性，从顶点\(v\)到顶点\(u\)不一定有路径，例如存在单向边的情况，所以A错误。 
- B选项：在无向图中，若两个顶点之间有边，根据无向图连通的定义，这两个顶点一定连通，B正确。 
- C选项：有向图中，从顶点\(u\)到顶点\(v\)有路径，从顶点\(v\)到顶点\(u\)有可能存在路径，比如存在双向边的情况，所以C错误。 
- D选项：无向图中，两个顶点之间没有边，但可能通过其他顶点间接连通，不一定不连通，所以D错误。 
- **核心知识点**：有向图和无向图中路径、连通等概念的区别与联系，理解有向图中边的方向性对路径和连通性的影响，以及无向图中边的无向性决定的连通性特点。 
2. **答案**：A 
- **解析**： - A选项：简单路径是指路径中顶点不重复的路径，而不是顶点重复的路径，A选项说法错误。 
- B选项：回路的定义是起终点相同的路径，B选项说法正确。 
- C选项：欧拉路径是指在图中遍历每条边恰好一次的路径，C选项说法正确。 
- D选项：哈密顿路径是指在图中遍历每个顶点恰好一次的路径，D选项说法正确。 
- **核心知识点**：图中各种路径的定义，包括简单路径、回路、欧拉路径、哈密顿路径等，准确把握不同路径定义的核心要点。 
# 三、计算题 
1. **答案**：该无向图是连通图。 
- **解析**：对于给定的无向图，顶点集合\(V = \{A, B, C, D, E\}\)，边集合\(E = \{(A, B), (A, C), (B, C), (B, D), (C, D), (D, E)\}\)。从顶点\(A\)出发，通过边\((A, B)\)可到达\(B\)，通过边\((A, C)\)可到达\(C\)；因为有边\((B, C)\)，所以\(B\)和\(C\)相互可达；又有边\((B, D)\)和\((C, D)\)，则\(A\)、\(B\)、\(C\)都可到达\(D\)；最后由边\((D, E)\)可知，\(A\)、\(B\)、\(C\)、\(D\)都能到达\(E\)。即对于图中任意两个顶点，都存在路径相连，所以该无向图是连通图。 
- **核心知识点**：无向图连通性的判断方法，通过检查图中顶点之间是否存在路径来确定无向图的连通性，若任意两个顶点之间都有路径，则该无向图是连通图。 
2. **答案**：该有向图是强连通图。 
- **解析**：对于给定的有向图，顶点集合\(V = \{A, B, C, D\}\)，边集合\(E = \{(A, B), (B, C), (C, D), (D, A), (A, C)\}\)。从顶点\(A\)出发，通过边\((A, B)\)到达\(B\)，再通过\((B, C)\)到达\(C\)，接着通过\((C, D)\)到达\(D\)，然后由\((D, A)\)回到\(A\)，说明从\(A\)出发可以到达图中所有顶点，且所有顶点都能回到\(A\)；从顶点\(B\)出发，经过\((B, C)\)、\((C, D)\)、\((D, A)\)、\((A, B)\)也能回到\(B\)，并且能到达其他所有顶点；同理，从顶点\(C\)和\(D\)出发，也都能到达图中所有顶点且能回到自身。即对于该有向图中任意两个顶点\(u\)和\(v\)，既存在从\(u\)到\(v\)的路径，也存在从\(v\)到\(u\)的路径，所以该有向图是强连通图。 
- **核心知识点**：有向图强连通性的定义及判断方法，有向图中若任意两个顶点相互可达，则该有向图是强连通图，需要对图中每个顶点进行分析判断。 
# 四、应用题 
1. **答案**：从城市\(A\)到城市\(E\)的最短路径是\(A - B - D - E\)，最短路径长度为\(10 + 25 + 35 = 70\)。 
- **解析**：已知边集合\(E = \{(A, B, 10), (A, C, 15), (B, C, 20), (B, D, 25), (C, D, 30), (D, E, 35)\}\)。可以使用迪杰斯特拉（Dijkstra）算法等最短路径算法来求解。从\(A\)出发，首先\(A - B\)的距离为\(10\)，\(A - C\)的距离为\(15\)，\(B\)距离\(A\)更近；以\(B\)为中间点，\(B - D\)的距离为\(25\)，此时\(A - B - D\)的总距离为\(10 + 25 = 35\)；再以\(D\)为中间点，\(D - E\)的距离为\(35\)，所以\(A - B - D - E\)的总距离为\(10 + 25 + 35 = 70\)。其他可能的路径如\(A - C - D - E\)的距离为\(15 + 30 + 35 = 80\)等，比较后可知\(A - B - D - E\)是最短路径。 
- **核心知识点**：最短路径算法（如迪杰斯特拉算法）的原理和应用，图中边权重的概念，边的权重表示路径的长度，在求解最短路径时，根据边的权重计算不同路径的总长度并进行比较。 
2. **答案**：该社交网络是连通图。 
- **解析**：已知社交网络中顶点集合为\(\{A, B, C, D\}\)，边集合\(E = \{(A, B), (A, C), (B, C), (B, D), (C, D)\}\)。从顶点\(A\)出发，通过边\((A, B)\)可到达\(B\)，通过边\((A, C)\)可到达\(C\)；因为有边\((B, C)\)，所以\(B\)和\(C\)相互可达；又有边\((B, D)\)和\((C, D)\)，则\(A\)、\(B\)、\(C\)都可到达\(D\)。即对于社交网络中任意两个用户顶点，都存在路径相连，所以该社交网络是连通图。 
- **核心知识点**：无向图连通性的判断，将社交网络抽象为无向图，用户为顶点，用户之间的关系为边，根据无向图连通性的定义判断社交网络中任意两个用户是否可达，若可达则社交网络是连通的。

第二节题目：
一、基础概念题
1. 比较邻接矩阵和邻接表的优缺点，并分别说明它们适用的场景（如稠密图、稀疏图）。
2. 给定一个图，顶点数为V，边数为E。请填写以下操作在不同存储方式下的时间复杂度：
操作	邻接表	邻接矩阵	边集	链式前向星
判断顶点u和v是否邻接				
遍历顶点u的所有邻接点				
添加一条边u→v				

二、代码实现题
3. 邻接表的BFS遍历
使用C++实现邻接表存储的无向图，并从顶点0出发进行BFS遍历，输出访问顺序。
输入示例：顶点数 V=4，边集为 {{0,1}, {0,2}, {2,3}}。
输出示例：0 1 2 3
4. 链式前向星的DFS遍历
使用链式前向星存储有向图，并实现非递归（栈）的DFS遍历，从顶点0出发输出访问顺序。
输入示例：顶点数 V=3，边集为 {{0,1}, {0,2}, {2,1}}。
输出示例：0 2 1（依赖遍历顺序）
三、综合应用题
5. 最短路径问题
给定一个无权无向图（边权为1），使用邻接表存储，编写BFS算法求解从顶点 s 到顶点 t 的最短路径长度。若不可达返回-1。
输入示例：
V=5, E=6, edges={{0,1}, {0,2}, {1,3}, {2,3}, {2,4}, {3,4}}  
s=0, t=4  
输出：3（路径0→2→4）
6. 图的连通分量计数
使用邻接矩阵存储图，通过DFS遍历统计图中的连通分量数量。
输入示例：
V=5, edges={{0,1}, {1,2}, {3,4}}  // 图分为两个连通分量  
输出：2
四、进阶思考题
7. 存储方式选择与优化
假设需要频繁进行两种操作：(1) 判断任意两顶点是否邻接；(2) 遍历某个顶点的所有邻接点。
若图的顶点数 V=1000，边数 E=3000，你会选择哪种存储方式？为什么？如果边数变为 E=800000，选择会变化吗？

第二节参考答案及解析：
# 一、基础概念题 
1. **邻接矩阵和邻接表优缺点及适用场景** 
 **邻接矩阵** 
 **优点**：直观，便于判断两顶点是否相邻，时间复杂度为$O(1)$；方便获取顶点的度，对于无向图，顶点$v$的度是第$v$行（或列）非零元素的个数，对于有向图，出度是第$v$行非零元素的个数，入度是第$v$列非零元素的个数；矩阵运算可用于图的一些算法，如弗洛伊德（Floyd）算法求最短路径。 
 **缺点**：存储空间大，对于有$V$个顶点的图，需要$V^2$的空间，若为稀疏图会浪费大量空间；插入和删除边的操作时间复杂度高，为$O(1)$，但修改矩阵元素涉及到对矩阵的操作。 
 **适用场景**：稠密图，即边数$E$接近$V^2$的图；需要频繁判断顶点间是否相邻的场景；一些基于矩阵运算的图算法。 
 **邻接表** -
**优点**：节省空间，对于稀疏图，只存储存在的边，空间复杂度为$O(V + E)$；插入和删除边的操作相对简单，时间复杂度为$O(1)$（不考虑查找边的时间）；便于遍历每个顶点的邻接点，时间复杂度为$O(d(v))$，$d(v)$为顶点$v$的度。 -
**缺点**：判断两顶点是否相邻需要遍历顶点$u$的邻接表，时间复杂度为$O(d(u))$；获取顶点的度需要遍历邻接表统计邻接点个数，时间复杂度为$O(d(v))$。 
 **适用场景**：稀疏图，即边数$E$远小于$V^2$的图；需要频繁遍历顶点邻接点的场景。 
2. **不同存储方式下操作的时间复杂度**
操作	邻接表	邻接矩阵	边集	链式前向星
判断顶点u和v是否邻接	$O(d(u))$	$O(1)$	$O(E)$	$O(d(u))$
遍历顶点u的所有邻接点	$O(d(u))$	$O(V)$	$O(E)$	$O(d(u))$
添加一条边u→v	$O(1)$	$O(1)$	$O(1)$	$O(1)$
解析：  **判断顶点u和v是否邻接** 
**邻接表**：需要遍历顶点$u$的邻接表查找顶点$v$，时间复杂度为$O(d(u))$，$d(u)$为顶点$u$的度。 - **邻接矩阵**：直接访问矩阵中对应位置元素，时间复杂度为$O(1)$。 - **边集**：需要遍历边集查找是否存在边$(u, v)$，时间复杂度为$O(E)$，$E$为边数。 - **链式前向星**：类似邻接表，需要遍历以顶点$u$为起点的边链表查找是否存在边$(u, v)$，时间复杂度为$O(d(u))$。 
 **遍历顶点u的所有邻接点** 
**邻接表**：遍历顶点$u$的邻接表，时间复杂度为$O(d(u))$，$d(u)$为顶点$u$的度。 - **邻接矩阵**：遍历第$u$行元素，时间复杂度为$O(V)$。 - **边集**：遍历边集，时间复杂度为$O(E)$。 - **链式前向星**：遍历以顶点$u$为起点的边链表，时间复杂度为$O(d(u))$。 -
**添加一条边u→v** 
 **邻接表**：在顶点$u$的邻接表中添加节点，时间复杂度为$O(1)$。 - **邻接矩阵**：修改矩阵中对应位置元素，时间复杂度为$O(1)$。 - **边集**：在边集中添加边$(u, v)$，时间复杂度为$O(1)$。 - **链式前向星**：在以顶点$u$为起点的边链表头部插入边节点，时间复杂度为$O(1)$。
 # 二、代码实现题 
3. **邻接表的BFS遍历** 
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// 邻接表存储无向图
vector<int> adj[100];
bool vis[100];

void bfs(int start) {
    queue<int> q;
    q.push(start);
    vis[start] = true;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        cout << u << " ";
        for (int v : adj[u]) {
            if (!vis[v]) {
                q.push(v);
                vis[v] = true;
            }
        }
    }
}

int main() {
    int V = 4;
    // 添加边
    adj[0].push_back(1);
    adj[1].push_back(0);
    adj[0].push_back(2);
    adj[2].push_back(0);
    adj[2].push_back(3);
    adj[3].push_back(2);

    // 初始化访问数组
    for (int i = 0; i < V; ++i) {
        vis[i] = false;
    }

    bfs(0);
    return 0;
} -
**解析**：首先定义邻接表`adj`存储无向图，`vis`数组记录顶点是否被访问。`bfs`函数实现广度优先遍历，使用队列`q`存储待访问的顶点。从起始顶点`start`开始，将其入队并标记为已访问，然后循环取出队列头部顶点，输出该顶点，遍历其邻接点，若邻接点未被访问则入队并标记为已访问。在`main`函数中添加边并初始化访问数组，最后调用`bfs(0)`从顶点0开始进行BFS遍历。 
 **核心知识点**：邻接表的存储方式；广度优先遍历（BFS）算法，利用队列实现逐层访问顶点；访问数组的使用，用于标记顶点是否已被访问。
4. **链式前向星的DFS遍历（非递归，使用栈）** 
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

const int N = 100;
struct Edge {
    int to;
    int next;
};
Edge edge[N];
int head[N], cnt = 0;
bool vis[N];

// 添加边
void addEdge(int u, int v) {
    edge[cnt].to = v;
    edge[cnt].next = head[u];
    head[u] = cnt++;
}

// 链式前向星DFS遍历（非递归，使用栈）
void dfs(int start) {
    stack<int> st;
    st.push(start);
    vis[start] = true;
    while (!st.empty()) {
        int u = st.top();
        st.pop();
        cout << u << " ";
        for (int i = head[u]; i != -1; i = edge[i].next) {
            int v = edge[i].to;
            if (!vis[v]) {
                st.push(v);
                vis[v] = true;
            }
        }
    }
}

int main() {
    int V = 3;
    // 初始化head数组
    for (int i = 0; i < V; ++i) {
        head[i] = -1;
    }

    // 添加边
    addEdge(0, 1);
    addEdge(0, 2);
    addEdge(2, 1);

    // 初始化访问数组
    for (int i = 0; i < V; ++i) {
        vis[i] = false;
    }

    dfs(0);
    return 0;
}
**解析**：定义结构体`Edge`存储边的信息，包括目标顶点`to`和指向下一条边的指针`next`。`head`数组存储每个顶点的第一条边在`edge`数组中的下标。`addEdge`函数用于添加边，将边信息存入`edge`数组并更新`head`数组。`dfs`函数实现链式前向星的非递归DFS遍历，使用栈`st`存储待访问的顶点。从起始顶点`start`开始，将其入栈并标记为已访问，然后循环取出栈顶顶点，输出该顶点，遍历以该顶点为起点的边链表，若目标顶点未被访问则入栈并标记为已访问。在`main`函数中初始化`head`数组，添加边并初始化访问数组，最后调用`dfs(0)`从顶点0开始进行DFS遍历。 
 **核心知识点**：链式前向星的存储方式；深度优先遍历（DFS）算法，利用栈实现非递归的DFS；结构体和数组的使用来实现链式前向星存储图；访问数组的使用，用于标记顶点是否已被访问。 
# 三、综合应用题 
5. **最短路径问题（BFS算法）** 

#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int N = 100;
vector<int> adj[N];
bool vis[N];
int dist[N];

// BFS求最短路径
int bfs(int s, int t) {
    queue<int> q;
    q.push(s);
    vis[s] = true;
    dist[s] = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : adj[u]) {
            if (!vis[v]) {
                q.push(v);
                vis[v] = true;
                dist[v] = dist[u] + 1;
                if (v == t) {
                    return dist[v];
                }
            }
        }
    }
    return -1;
}

int main() {
    int V = 5, E = 6;
    // 添加边
    adj[0].push_back(1);
    adj[1].push_back(0);
    adj[0].push_back(2);
    adj[2].push_back(0);
    adj[1].push_back(3);
    adj[3].push_back(1);
    adj[2].push_back(3);
    adj[3].push_back(2);
    adj[2].push_back(4);
    adj[4].push_back(2);
    adj[3].push_back(4);
    adj[4].push_back(3);

    int s = 0, t = 4;
    // 初始化访问数组和距离数组
    for (int i = 0; i < V; ++i) {
        vis[i] = false;
        dist[i] = -1;
    }

    cout << bfs(s, t) << endl;
    return 0;
} -
**解析**：定义邻接表`adj`存储无向图，`vis`数组记录顶点是否被访问，`dist`数组记录从起始顶点到其他顶点的最短距离。`bfs`函数实现BFS算法求最短路径，使用队列`q`存储待访问的顶点。从起始顶点`s`开始，将其入队并标记为已访问，距离设为0，然后循环取出队列头部顶点，遍历其邻接点，若邻接点未被访问则入队并标记为已访问，更新其距离为当前顶点距离加1，若邻接点为目标顶点`t`，则返回其距离。若遍历完所有顶点仍未找到目标顶点，则返回-1。在`main`函数中添加边并初始化访问数组和距离数组，最后调用`bfs(s, t)`求解从顶点`s`到顶点`t`的最短路径长度。 -
**核心知识点**：邻接表的存储方式；广度优先遍历（BFS）算法，利用队列实现逐层访问顶点；访问数组和距离数组的使用，访问数组用于标记顶点是否已被访问，距离数组用于记录从起始顶点到其他顶点的最短距离。
6. **图的连通分量计数（DFS遍历）** 
#include <iostream>
#include <vector>
using namespace std;

const int N = 100;
int adjMatrix[N][N];
bool vis[N];

// DFS遍历
void dfs(int u) {
    vis[u] = true;
    for (int v = 0; v < N; ++v) {
        if (adjMatrix[u][v] &&!vis[v]) {
            dfs(v);
        }
    }
}

// 统计连通分量数量
int countConnectedComponents(int V) {
    int count = 0;
    for (int i = 0; i < V; ++i) {
        if (!vis[i]) {
            count++;
            dfs(i);
        }
    }
    return count;
}

int main() {
    int V = 5;
    // 添加边到邻接矩阵
    adjMatrix[0][1] = 1;
    adjMatrix[1][0] = 1;
    adjMatrix[1][2] = 1;
    adjMatrix[2][1] = 1;
    adjMatrix[3][4] = 1;
    adjMatrix[4][3] = 1;

    // 初始化访问数组
    for (int i = 0; i < V; ++i) {
        vis[i] = false;
    }

    cout << countConnectedComponents(V) << endl;
    return 0;
}
 **解析**：定义邻接矩阵`adjMatrix`存储图，`vis`数组记录顶点是否被访问。`dfs`函数实现深度优先遍历，从顶点`u`开始，标记其为已访问，然后遍历邻接矩阵中与顶点`u`相邻且未被访问的顶点，递归调用`dfs`进行遍历。`countConnectedComponents`函数统计连通分量数量，遍历所有顶点，若顶点未被访问，则连通分量数量加1，并调用`dfs`进行遍历。在`main`函数中添加边到邻接矩阵并初始化访问数组，最后调用`countConnectedComponents(V)`统计连通分量数量。 -
**核心知识点**：邻接矩阵的存储方式；深度优先遍历（DFS）算法，递归实现对图的遍历；访问数组的使用，用于标记顶点是否已被访问；连通分量的概念，通过DFS遍历统计图中连通分量的数量。 
# 四、进阶思考题 
7. **存储方式选择与优化** -
当$V = 1000$，$E = 3000$时，为稀疏图（因为边数$E$远小于$V^2 = 1000\times1000 = 1000000$），应选择邻接表或链式前向星存储。因为邻接矩阵存储需要$V^2 = 1000000$的空间，会浪费大量空间，而邻接表和链式前向星的空间复杂度为$O(V + E) = O(1000 + 3000) = O(4000)$，空间效率高。对于操作(1)判断任意两顶点是否邻接，邻接表时间复杂度为$O(d(u))$，链式前向星为$O(d(u))$，虽然不如邻接矩阵的$O(1)$，但由于是稀疏图，平均度数$d(u) = \frac{2E}{V} = \frac{2\times3000}{1000} = 6$较小，实际判断时间可接受；对于操作(2)遍历某个顶点的所有邻接点，邻接表和链式前向星时间复杂度为$O(d(u))$，邻接矩阵为$O(V)$，邻接表和链式前向星更优。所以选择邻接表或链式前向星。 
 当$V = 1000$，$E = 800000$时，为稠密图（因为边数$E$接近$V^2 = 1000\times1000 = 1000000$），应选择邻接矩阵存储。因为邻接表和链式前向星存储虽然空间复杂度为$O(V + E) = O(1000 + 800000) = O(801000)$，但对于操作(1)判断任意两顶点是否邻接，邻接矩阵时间复杂度为$O(1)$，邻接表和链式前向星为$O(d(u))$，稠密图中平均度数$d(u) = \frac{2E}{V} = \frac{2\times800000}{1000} = 1600$较大，邻接矩阵在判断顶点邻接关系上效率更高；对于操作(2)遍历某个顶点的所有邻接点，邻接矩阵时间复杂度为$O(V)$，邻接表和链式前向星为$O(d(u))$，由于是稠密图，$O(V)$和$O(d(u))$相差不大，且邻接矩阵更便于操作和实现。所以选择邻接矩阵。 
 **核心知识点**：图的存储方式（邻接矩阵、邻接表、链式前向星）及其优缺点；稀疏图和稠密图的概念；根据图的特点（顶点数、边数）和操作需求（判断顶点邻接关系、遍历邻接点）选择合适的存储方式；时间复杂度和空间复杂度的分析，用于评估不同存储方式在不同操作下的效率。
第三节题目
1. 某外汇交易平台提供货币兑换汇率表。例如，1美元兑换0.9欧元，1欧元兑换110日元，1日元兑换0.01美元。设计一个算法，判断是否存在通过循环兑换获利的可能（即负权环）。
【输入】
货币种类数 n 和兑换关系数 m。接下来 m 行，每行为货币A与货币B汇率，表示1单位A可兑换的B的数量。
【输出】
“存在套利机会” 或 “无套利机会”。
2. 在社交网络中，若两个人的最短好友链长度 ≤6，则称他们满足“六度空间”理论。给定好友关系图（无向无权图），计算所有点对中最短路径的最大值，验证是否 ≤6。
【输入】
用户数 n 和好友关系数 m。接下来 m 行，每行为 u v，表示用户 u 和 v 是好友。
【输出】
最长的最短路径长度。若>6，输出“不符合六度空间”，否则输出“符合”。
第三节参考答案

# 一、外汇交易平台套利检测问题 
## 题目分析 判断是否存在通过循环兑换获利的可能，等价于在有向图中检测是否存在**负权环**。货币兑换关系可建模为有向图：每个货币为顶点，兑换关系`A→B`的汇率`r`表示从A到B的边权为`log(r)`。若存在环`A1→A2→…→An→A1`，则总兑换倍数为各边权乘积`r1*r2*…*rn`。若该乘积>1（即总对数和`log(r1)+log(r2)+…+log(rn)>0`），则存在套利机会，对应图中存在**正权环**。为了利用最短路径算法检测环，可将边权取负数，转化为检测**负权环**问题。 
## 核心知识点 - **图的建模**：将货币兑换关系转化为有向图，边权为对数形式的兑换率。 - **Bellman-Ford算法**：用于检测图中是否存在负权环，适用于边数较少的场景。 - **SPFA算法**：Bellman-Ford的优化版本，利用队列优化松弛操作，可高效检测负权环。 
## 解法代码（SPFA算法） 
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int MAXN = 105;
const int MAXM = 1005;

struct Edge {
    int to;
    double weight;
};

vector<Edge> adj[MAXN];
int n, m;
double dist[MAXN];
int cnt[MAXN]; // 记录每个节点的入队次数
bool inQueue[MAXN];

bool hasNegativeCycle() {
    memset(dist, 0, sizeof(dist)); // 初始距离设为0（假设从任意节点出发均可形成环）
    memset(cnt, 0, sizeof(cnt));
    memset(inQueue, false, sizeof(inQueue));
    queue<int> q;

    // 为了检测所有可能的环，将所有节点加入队列（类似多源最短路径）
    for (int i = 0; i < n; ++i) {
        q.push(i);
        inQueue[i] = true;
    }

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inQueue[u] = false;

        for (const Edge& e : adj[u]) {
            int v = e.to;
            double w = e.weight;
            // 松弛操作：若通过u到v的路径更短（即总对数和更大，对应实际兑换倍数更大）
            if (dist[v] < dist[u] + w) {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) { // 若一个节点入队次数超过n次，说明存在环
                    return true;
                }
                if (!inQueue[v]) {
                    q.push(v);
                    inQueue[v] = true;
                }
            }
        }
    }
    return false;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int a, b;
        double rate;
        cin >> a >> b >> rate;
        // 边权取对数，转换为加法问题：log(a->b) = ln(rate)
        // 检测正权环等价于检测负权环（将边权取反）
        adj[a].push_back({b, log(rate)});
    }

    if (hasNegativeCycle()) {
        cout << "存在套利机会" << endl;
    } else {
        cout << "无套利机会" << endl;
    }
    return 0;
}
 ## 解析 
1. **建模**：将每种货币视为顶点，兑换关系视为有向边，边权为汇率的自然对数`log(rate)`。若存在环使得各边权之和`sum(log(rate)) > 0`，则总兑换倍数`exp(sum(log(rate))) > 1`，存在套利机会。 
2. **负权环检测**：将边权取反（即存储为`-log(rate)`），问题转化为检测图中是否存在负权环。使用SPFA算法，通过记录每个节点的入队次数，若某个节点入队次数超过顶点数`n`，说明存在环。 
3. **多源初始化**：为了检测所有可能的环，将所有节点作为起点加入队列，确保覆盖所有可能的环结构。 
# 二、六度空间理论验证问题 
## 题目分析 给定无向无权图，计算所有点对的最短路径长度，并找到最大值。若最大值≤6，则符合六度空间理论，否则不符合。由于图是无权的，最短路径可通过**广度优先搜索（BFS）**高效计算，每个节点作为起点进行一次BFS，记录到其他节点的最短距离。 
## 核心知识点 - **BFS算法**：适用于无权图的最短路径计算，时间复杂度为O(V+E)。 - **多源最短路径**：对每个节点执行BFS，获取其到所有其他节点的最短路径。 
## 解法代码（BFS实现） #include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

const int MAXN = 1005;

vector<int> adj[MAXN];
int n, m;
int max_dist = 0; // 记录最长最短路径

void bfs(int start) {
    vector<int> dist(n, -1);
    queue<int> q;
    q.push(start);
    dist[start] = 0;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
                if (dist[v] > max_dist) {
                    max_dist = dist[v]; // 更新最长距离
                }
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u); // 无向图，双向加边
    }

    // 对每个节点执行BFS
    for (int i = 0; i < n; ++i) {
        bfs(i);
    }

    if (max_dist > 6) {
        cout << "不符合六度空间" << endl;
    } else {
        cout << "符合" << endl;
    }
    return 0;
}
## 解析 1. **图的存储**：使用邻接表存储无向图，每个节点的好友关系双向添加。 2. **BFS计算最短路径**：对每个节点作为起点进行BFS，记录到其他节点的距离`dist[v]`。BFS的层级对应最短路径长度，因此无需显式维护距离数组，只需在遍历过程中更新最长距离`max_dist`。 3. **结果判断**：遍历所有点对后，若`max_dist`超过6，则输出“不符合”，否则输出“符合”。 

