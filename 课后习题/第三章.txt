第三章第一节
一、判断题 
1. 二叉堆的根节点一定是全堆的最小值。 
2. 在最大堆中插入新元素后，只需调整根节点即可恢复堆性质。 
二、选择题 
1. 下列选项中，符合堆性质的结构是？ 
A. 根节点为5，左子节点为3，右子节点为7 
B. 根节点为5，左子节点为7，右子节点为3
C. 根节点为5，左子节点为5，右子节点为5 
D. 以上均符合 
2. 删除堆顶元素后，堆调整的方式是？ 
A. 将末元素移至堆顶，然后向下交换 
B. 将堆顶元素与末元素交换后删除
C. 直接删除堆顶元素，无需调整
D. 重新构建整个堆
三、填空题
1. 在空堆中依次插入元素3、1、5，形成最大堆后，根节点的值为____。
2. 堆的时间复杂度主要取决于树的____，其值为____。
四、简答题
1. 简述堆的"子树自堆性"对插入操作的意义。
2. 为什么删除堆顶元素后，未参与交换的子树仍保持堆性质？

答案：
一、判断题
1. 答案：错误
解析：二叉堆分为最大堆和最小堆。在最小堆中，根节点是最小值；在最大堆中，根节点是最大值。题目没有指明是哪种堆，因此不能一概而论。

2. 答案：错误
解析：在最大堆中插入新元素后，通常需要从插入位置（通常是末尾）开始向上调整（称为"上浮"操作），直到找到合适的位置，而不是只调整根节点。

二、选择题
1. 答案：C
解析：
选项A：如果是最大堆，5 < 7不满足；如果是最小堆，5 > 3不满足。但如果题目没有指明堆类型，且假设是最大堆，则不符合；假设是最小堆，也不符合。
选项B：如果是最大堆，5 < 7满足，5 < 3不满足；如果是最小堆，5 > 7不满足。
选项C：所有节点相同，无论最大堆还是最小堆都满足。
选项 D：由于选项 A、B 均不符合，故错误。

2. 答案：A
解析：删除堆顶元素的正确步骤是：将堆的最后一个元素移到堆顶，然后从堆顶开始向下调整（称为"下沉"操作），与较大的子节点交换，直到恢复堆性质。

三、填空题
1. 答案：5
解析：
插入3：堆为[3]
插入1：堆为[3,1]（无需调整）
插入5：堆为[3,1,5]，然后5上浮与3交换，得到[5,1,3]
最终最大堆的根节点是5。

2. 答案：高度，O(log n)
解析：堆通常实现为完全二叉树，其高度为log2n。插入和删除操作的时间复杂度都是O(log n)，因为最多需要从叶子节点调整到根节点或反之。

四、简答题
1. 答案：
堆的"子树自堆性"（即每个子树本身也是一个堆）对插入操作的意义在于：
①局部调整高效性：插入新元素时，只需从插入位置（通常为堆底）向上调整，无需遍历整个堆。由于子树本身是堆，调整过程中只需比较当前节点与父节点的值，若违反堆序则交换，直到满足堆性质。 例：大根堆插入新元素后，若新元素大于父节点，则交换，继续向上检查，直到找到合适位置或到达堆顶。
②保持堆结构的完整性：插入操作不会破坏其他子树的堆性质。因为调整路径仅涉及插入节点到根节点的路径，其他子树的 “自堆性” 未被干扰，无需额外处理。 例如：在完全二叉树结构的堆中，插入节点位于最后一个位置，其左右子树（若存在）本身已是合法堆，只需向上调整当前路径。
③时间复杂度可控：插入操作的时间复杂度为 O(log n)，其中 n 为堆的大小。这是因为堆的高度为 log n，调整过程最多需要从叶子节点到根节点的路径长度次比较和交换，而子树自堆性确保了这一过程的有效性。

2. 答案：
删除堆顶元素后，未参与交换的子树仍保持堆性质，这是因为：
堆的"子树自堆性"保证了每个子树本身已经是堆，在向下调整（下沉操作）过程中，我们只与需要交换的子节点进行交换。
未被交换的子树仍然满足堆性质，因为它们在调整前就是堆，调整过程中没有破坏它们的性质。只有当前节点可能不满足堆性质，需要通过交换来恢复
这种局部调整的性质使得我们可以用O(log n)的时间复杂度完成删除操作，而不需要重建整个堆。


第二节
一、判断题
1. 并查集是一种用于处理动态连通性问题的数据结构，它只能用于无向图。
2. 在并查集中，路径压缩操作可以显著提高查找操作的效率。
3. 并查集只能用于判断两个元素是否在同一集合中，不能用于计算集合的大小。
4. 并查集的合并操作（Union）必须按照元素的大小顺序进行。
5. 并查集的时间复杂度为 O(1)。
二、选择题
1. 在并查集中，路径压缩操作的作用是什么？
A. 增加树的高度
B. 减少树的高度
C. 增加集合的数量
D. 减少集合的数量
2. 并查集的按秩合并（UnionbyRank）操作的主要目的是什么？
A. 保持树的平衡
B. 增加树的高度
C. 减少树的节点数量
D. 增加集合的大小
3. 在并查集中，假设集合中有 n 个元素，经过若干次合并操作后，集合的总数
最多为：
A. n
B. n/2
C. 1
D. 无法确定
三、应用题
在一个社交网络中，有 n 个人，编号从 1 到 n。现在有若干条关系，每条关系
表示两个人是朋友。如果 A 和 B 是朋友，B 和 C 是朋友，那么 A 和 C 也
被认为是朋友。请判断任意两个人是否属于同一个社交圈。
输入：
第一行包含两个整数 n 和 m，分别表示人数和关系数。
接下来 m 行，每行包含两个整数 u 和 v，表示 u 和 v 是朋友。
最后一行包含两个整数 x 和 y，表示查询 x 和 y 是否属于同一个社交圈。
输出：
如果 x 和 y 属于同一个社交圈，输出“YES”；否则输出“NO”。

答案
一、判断题
1. 答案：错误 
解析：并查集主要用于处理无向图的连通性问题，但理论上也可通过特殊处理用于有向图（如处理强连通分量），但常规应用场景为无向图。

2.答案：正确 
解析：路径压缩通过将查找路径上的节点直接指向根节点，降低树的高度，从而显著提高后续查找操作的效率。

3. 答案：错误
解析：可以通过在每个根节点维护一个 size 属性，记录集合元素个数，从而支持计算集合大小。

4. 答案：错误 
解析：按秩合并（Union by Rank）是基于树的高度或规模决定合并顺序，以保持树的平衡，但并非 “必须按元素大小顺序”。

5. 答案：错误 
解析：经过路径压缩和按秩合并优化后，并查集的单次操作均摊时间复杂度接近 \(O(1)\)，但严格来说不是常数时间。

二、选择题
1. 答案：B 
解析：路径压缩通过将节点直接指向根节点，减少树的高度，提高查找效率。

2. 答案：A 
解析：按秩合并的目的是让高度较小的树合并到高度较大的树下，避免树退化成链表，保持树的平衡。

3. 答案：A 
解析：若所有元素均未合并，每个元素自成一个集合，总数最多为 n。

三、应用题
解题思路：
使用并查集维护社交圈的连通性，通过合并操作将朋友关系连通，最后查询两个节点的根节点是否一致。
关键步骤：
①初始化：每个节点的父节点初始化为自身。
②合并操作：将两个节点的根节点合并，实现连通。
③查找操作：通过路径压缩优化查找效率，判断两个节点的根是否一致。
代码实现（C++）：
#include <iostream>#include <vector>using namespace std;
class UnionFind {private:
    vector<int> parent;
public:
    UnionFind(int size) {
        parent.resize(size + 1);
        for (int i = 1; i <= size; i++) {
            parent[i] = i;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }

    void unite(int x, int y) {
        int fx = find(x);
        int fy = find(y);
        if (fx != fy) {
            parent[fy] = fx;
        }
    }};
int main() {
    int n, m;
    cin >> n >> m;
    UnionFind uf(n);

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        uf.unite(u, v);
    }

    int x, y;
    cin >> x >> y;
    cout << (uf.find(x) == uf.find(y) ? "YES" : "NO") << endl;

    return 0;}


第三节
一、基础题
1. 给定一棵完全二叉树，根为 1 号结点，求以下结点对的 LCA 和距离：
(7, 8)         (5, 9)         (3, 6)
2. 证明：在完全二叉树中，结点i的父结点为[i/2] 。
二、进阶题
1. 实现倍增法求解 LCA，并通过洛谷 P3379 提交测试。
【题目描述】：如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。
【输入格式】
第一行包含三个正整数 N,M,S，分别表示树的结点个数、询问的个数和树根结点的序号。
接下来 N−1 行每行包含两个正整数 x,y，表示 x 结点和 y 结点之间有一条直接连接的边（数据保证可以构成树）。
接下来 M 行每行包含两个正整数 a,b，表示询问 a 结点和 b 结点的最近公共祖先。
【输出格式】
输出包含 M 行，每行包含一个正整数，依次为每一个询问的结果。
2. 扩展代码支持计算树上任意两点距离，并处理m次查询。
三、拓展题
1. 动态树场景：若允许树的边权动态修改，如何优化距离计算？
2. 多结点 LCA：如何高效计算三个结点u,v,w的 LCA？

答案：
一、基础题
1. 完全二叉树结点对的 LCA 和距离
假设完全二叉树的结构如下（按层序编号）：
1
2       3
4   5         6   7
8   9 ...     

①(7, 8)
LCA：7 的父节点是 3，8 的父节点是 4，继续向上找共同祖先。3 的父节点是 1，4 的父节点是 2，2 和 3 的父节点是 1。因此 LCA 为 1。
距离：7 到 1 的路径长度为 2（7→3→1），8 到 1 的路径长度为 3（8→4→2→1），总距离为 2+3=5。
②(5, 9)
LCA：5 的父节点是 2，9 的父节点是 4，2 和 4 的父节点是 1。因此 LCA 为 1。
距离：5 到 1 的路径长度为 2（5→2→1），9 到 1 的路径长度为 3（9→4→2→1），总距离为 2+3=5。
③(3, 6)
LCA：3 是 6 的父节点，因此 LCA 为 3。
距离：6 到 3 的路径长度为 1，因此距离为 1。

2. 证明： 完全二叉树按层序编号，根为 1。对于任意结点 i：
若i=1，无父结点，结论成立（特殊情况）。
若i>1，假设 i 是左子结点，则 i=2k，父结点为 k = 2k/2 = i/2 。
若 i 是右子结点，则 i=2k+1，父结点为 k = (2k+1)/2 = i/2。 
综上，无论 i 是左子结点还是右子结点，父结点均为 i/2 。

二、进阶题
1. 核心解题思路：倍增法
代码实现：
#include <iostream>
#include <vector>using namespace std;
const int MAXN = 5e5 + 5;
const int LOG = 20;  // 足够处理2^20个节点的树

vector<int> adj[MAXN];  // 邻接表存储树结构
int depth[MAXN];        // 节点深度
int fa[MAXN][LOG];      // fa[u][k]: 节点u的第2^k级祖先

// 预处理每个节点的深度和祖先信息
void dfs(int u, int parent) {
    depth[u] = depth[parent] + 1;
    fa[u][0] = parent;
    // 预处理倍增数组
    for (int k = 1; k < LOG; k++)
        fa[u][k] = fa[fa[u][k-1]][k-1];
    // 递归处理子节点
    for (int v : adj[u]) {
        if (v != parent)
            dfs(v, u);
}
}

// 倍增法求
LCAint lca(int u, int v) {
    // 1. 先将u调整到更深的位置
    if (depth[u] < depth[v]) swap(u, v);
    // 2. 将u提升到与v相同深度
    for (int k = LOG-1; k >= 0; k--) {
        if (depth[u] - (1 << k) >= depth[v])
            u = fa[u][k];
    }
    // 3. 如果此时u和v相等，说明LCA是v
    if (u == v) return u;
    // 4. 同时提升u和v，直到它们的父节点相同
    for (int k = LOG-1; k >= 0; k--) {
        if (fa[u][k] != fa[v][k]) {
            u = fa[u][k];
            v = fa[v][k];
        }
    }
    // 5. 返回它们的父节点
return fa[u][0];
}

int main() {
    int n, m, s;
    cin >> n >> m >> s;
    
    // 读入树的边
    for (int i = 0; i < n-1; i++) {
        int x, y;
        cin >> x >> y;
        adj[x].push_back(y);
        adj[y].push_back(x);
    }
    
    // 预处理
    depth[0] = -1;  // 根节点的父节点深度设为-1
    dfs(s, 0);      // 从根节点开始DFS
    
    // 处理查询
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        cout << lca(a, b) << endl;
    }
    
return 0;
}

2. 思路：两点距离公式为 depth[u] + depth[v] - 2 *depth[LCA(u, v)]。
代码实现：
int get_distance(int u, int v) {
int l = lca(u, v); 
return depth[u] + depth[v] - 2 * depth[l]; 
}
 // 主函数中查询部分改为： 
while (m--) { 
int u, v; 
cin >> u >> v;
 cout << get_distance(u, v) << endl; 
}

三、拓展题
1. 问题分析：
①传统 LCA + 深度的方法适用于无权树或边权为 1 的树（距离即边数）。
②若边权动态修改且需计算实际距离（边权和），需维护每个结点到根的路径权值和。
优化方案：
①数据结构：使用 树链剖分 + 线段树 或 Link-Cut Tree（动态树）。
②维护信息：每个结点记录到父结点的边权，以及到根的路径权值和 sum[u]。
③动态修改：修改边权时，更新子树的 sum 值（树链剖分）或路径权值（Link-Cut Tree）。
④距离计算：distance(u, v) = sum[u] + sum[v] - 2*sum[LCA(u, v)]。
复杂度：每次修改和查询均为 \(O(\log n)\)。

2. 算法思路：
①两两求 LCA：先求 a = LCA(u, v)，再求 b = LCA(a, w)，则 b 即为三者的 LCA。
②证明：LCA 具有传递性，三个结点的共同祖先必为两两 LCA 的共同祖先。
代码实现：
int lca_three(int u, int v, int w) {
    int a = lca(u, v);
    int b = lca(a, w);
return b;
}
扩展：对于 k 个结点的 LCA，可依次合并，每次用当前 LCA 与下一个结点求 LCA，最终得到所有结点的共同 LCA。


